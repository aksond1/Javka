30 lvl - 10 lecture. JavaRush

# Task 1
```java
public class Solution {
    public A getOriginalObject(ObjectInputStream objectStream) {
        try {
            return (A) objectStream.readObject();
        } catch (Exception e) {
            System.out.println(e);
        }
        return null;
    }

    public class A implements Serializable {
    }

    public class B extends A {
        public B() {
            System.out.println("inside B");
        }
    }

    public static void main(String[] args) {

    }
}
```

# Task 2
```java
public class Solution {
    public class A implements Serializable {
        String name = "A";

        public A(String name) {
            this.name += name;
        }

        @Override
        public String toString() {
            return name;
        }
    }

    public class B extends A {
        String name = "B";

        public B(String name) {
            super(name);
            this.name += name;
        }
    }

    public class C extends B {
        String name = "C";

        public C(String name) {
            super(name);
            this.name = name;
        }
    }

    public static void main(String[] args) {

    }
}
```

# Task 3
```java
public class Solution implements Serializable {
    public static class A {

        protected String nameA = "A";

        public A(String nameA) {
            this.nameA += nameA;
        }

        public A() {

        }

    }

    public class B extends A implements Serializable {

        private String nameB;

        public B(String nameA, String nameB) {
            super(nameA);
            this.nameA += nameA;
            this.nameB = nameB;
        }

        private void writeObject(ObjectOutputStream oos) throws IOException {
            oos.defaultWriteObject();
            oos.writeObject(nameA);
        }

        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
            ois.defaultReadObject();
            nameA = (String) ois.readObject();
        }
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(arrayOutputStream);

        Solution solution = new Solution();
        B b = solution.new B("B2", "C33");
        System.out.println("nameA: " + b.nameA + ", nameB: " + b.nameB);

        oos.writeObject(b);

        ByteArrayInputStream arrayInputStream = new ByteArrayInputStream(arrayOutputStream.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(arrayInputStream);

        B b1 = (B) ois.readObject();
        System.out.println("nameA: " + b1.nameA + ", nameB: " + b1.nameB);
    }
}
```

# Task 4
```java
public class Solution implements Serializable {

    public static void main(String args[]) throws Exception {
        FileOutputStream fileOutput = new FileOutputStream("your.file.name");
        ObjectOutputStream outputStream = new ObjectOutputStream(fileOutput);

        Solution solution = new Solution();
        outputStream.writeObject(solution);

        fileOutput.close();
        outputStream.close();

        //load
        FileInputStream fiStream = new FileInputStream("your.file.name");
        ObjectInputStream objectStream = new ObjectInputStream(fiStream);

        Solution loadedObject = (Solution) objectStream.readObject();

        fiStream.close();
        objectStream.close();

        //Attention!!
        System.out.println(loadedObject.size());
    }

    private Map<String, String> m = new HashMap<>();

    public Map<String, String> getMap() {
        return m;
    }

    public Solution() {
        m.put("Mickey", "Mouse");
        m.put("Mickey", "Mantle");
    }
    

    public int size() {
        return m.size();
    }
}
```

# Task 5
```java
public class Solution {

    public static class Person implements Serializable {
        String firstName;
        String lastName;
        transient String fullName;
        transient final String greeting;
        String country;
        Sex sex;
        transient PrintStream outputStream;
        transient Logger logger;

        Person(String firstName, String lastName, String country, Sex sex) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.fullName = String.format("%s, %s", lastName, firstName);
            this.greeting = "Hello, ";
            this.country = country;
            this.sex = sex;
            this.outputStream = System.out;
            this.logger = Logger.getLogger(String.valueOf(Person.class));
        }
    }

    enum Sex {
        MALE,
        FEMALE
    }

    public static void main(String[] args) {

    }
}
```

# Task 6
```java
public class Solution implements Serializable {
    public static class SubSolution extends Solution {
        private void writeObject(ObjectOutputStream oos) throws IOException {
            throw new NotSerializableException();
        }

        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
            throw new NotSerializableException();
        }
    }

    public static void main(String[] args) {

    }
}
```

# Task 7
```java
public class Solution implements Serializable, AutoCloseable {
    transient private FileOutputStream stream;
    private String fileName;

    public Solution(String fileName) throws FileNotFoundException {
        this.fileName = fileName;
        this.stream = new FileOutputStream(fileName);
    }

    public void writeObject(String string) throws IOException {
        stream.write(string.getBytes());
        stream.write("\n".getBytes());
        stream.flush();
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        stream = new FileOutputStream(fileName, true);
    }

    @Override
    public void close() throws Exception {
        System.out.println("Closing everything!");
        stream.close();
    }

    public static void main(String[] args) {

    }
}
```

# Task 8
```java
public class Solution {
    public static void main(String[] s) {
        A a = new C();
        a.method2();
    }

    public static class A {
        private void method1() {
            System.out.println("A class, method1");
        }

        public void method2() {
            System.out.println("A class, method2");
            method1();
        }
    }

    public static class B extends A {
        public void method1() {
            super.method2();
            System.out.println("B class, method1");
        }

        public void method2() {
            System.out.println("B class, method2");
        }
    }

    public static class C extends B {
        public void method1() {
            System.out.println("C class, method1");
        }

        public void method2() {
            System.out.println("C class, method2");
            super.method1();
        }
    }
}
```

# Task 9
```java
public class Solution implements Serializable {
    int node;
    List<Solution> edges = new LinkedList<>();

    public static void main(String[] args) {

    }
}
```

### There are also +3 very hard tasks in this lecture, I guess I'm too weak for now to solve them. I'll definitely return to them soon, I just have to solve them!

<br><br>
32 lvl - 2 lecture. JavaRush

# Task 1
```java
public class Solution {
    public static void main(String[] args) throws IOException {
        String path = args[0];
        String resultFileAbsolutePath = args[1];

        File source = new File(resultFileAbsolutePath);
        File destination = new File(source.getParentFile() + "/allFilesContent.txt");

        FileUtils.renameFile(source, destination);

        Map<String, byte[]> map = writeFiles(path);

        try (FileOutputStream stream = new FileOutputStream(destination)) {
            for (byte[] bytes : map.values()) {
                stream.write(bytes);
                stream.write("\n".getBytes());
            }
        }
    }

    public static Map<String, byte[]> writeFiles(String path) throws IOException {
        Map<String, byte[]> files = new TreeMap<>();

        EnumSet<FileVisitOption> options = EnumSet.of(FileVisitOption.FOLLOW_LINKS);
        Files.walkFileTree(Paths.get(path), options, 20, new GetFiles(files));

        return files;
    }

    public static class GetFiles extends SimpleFileVisitor<Path> {
        private Map<String, byte[]> files;

        public GetFiles(Map<String, byte[]> files) {
            this.files = files;
        }

        public FileVisitResult visitFile(Path path, BasicFileAttributes basicFileAttributes) throws IOException {
            File file = path.toFile();
            if (file.isFile()) {
                if (file.length() <= 50) {
                    files.put(path.getFileName().toString(), Files.readAllBytes(path));
                }
            }
            return visitFile(path, basicFileAttributes);
        }
    }
}
```

# Task 2
```java
public class Solution {
    public static List<String> getFileTree(String root) throws IOException {
        List<String> list = new ArrayList<>();

        EnumSet<FileVisitOption> options = EnumSet.of(FileVisitOption.FOLLOW_LINKS);
        Files.walkFileTree(Paths.get(root), options, 20, new GetFiles(list));

        return list;
    }

    public static class GetFiles extends SimpleFileVisitor<Path> {
        private List<String> files;

        public GetFiles(List<String> files) {
            this.files = files;
        }

        public FileVisitResult visitFile(Path path, BasicFileAttributes basicFileAttributes) throws IOException {
            String source = path.toAbsolutePath().toString();
            files.add(source);
            return FileVisitResult.CONTINUE;
        }
    }

    public static void main(String[] args) {

    }
}
```

# Task 3
```java
public class SearchFileVisitor extends SimpleFileVisitor<Path> {
    private String partOfName;
    private String partOfContent;
    private int minSize;
    private int maxSize;
    private List<Path> foundFiles = new ArrayList<>();

    public List<Path> getFoundFiles() {
        return foundFiles;
    }

    public void setPartOfName(String partOfName) {
        this.partOfName = partOfName;
    }

    public void setPartOfContent(String partOfContent) {
        this.partOfContent = partOfContent;
    }

    public void setMinSize(int minSize) {
        this.minSize = minSize;
    }

    public void setMaxSize(int maxSize) {
        this.maxSize = maxSize;
    }




    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        byte[] content = Files.readAllBytes(file); // розмір файлу: content.length


        if (partOfName != null && !file.getFileName().toString().contains(partOfName)) {
            return FileVisitResult.CONTINUE;
        }
        if (partOfContent != null && !partOfContent.isEmpty()) {
            if (!new String(content).contains(partOfContent)) {
                return FileVisitResult.CONTINUE;
            }
        }
        if (maxSize > 0 && content.length > maxSize) {
            return FileVisitResult.CONTINUE;
        }
        if (minSize > 0 && content.length < minSize) {
            return FileVisitResult.CONTINUE;
        }

        foundFiles.add(file);
        return super.visitFile(file, attrs);
    }
}


public class Solution {

    public static void main(String[] args) throws IOException {
        SearchFileVisitor searchFileVisitor = new SearchFileVisitor();

        searchFileVisitor.setPartOfName("amigo");
        searchFileVisitor.setPartOfContent("programmer");
        searchFileVisitor.setMinSize(500);
        searchFileVisitor.setMaxSize(10000);

        Files.walkFileTree(Paths.get("D:/SecretFolder"), searchFileVisitor);

        List<Path> foundFiles = searchFileVisitor.getFoundFiles();
        for (Path file : foundFiles) {
            System.out.println(file);
        }
    }

}
```

<br><br>
32 lvl - 4 lecture. JavaRush

# Task 1
```java
public class Solution {
    public static byte[] readBytes(String fileName) throws IOException {
        return Files.readAllBytes(Paths.get(fileName));
    }

    public static List<String> readLines(String fileName) throws IOException {
        return Files.readAllLines(Paths.get(fileName));
    }

    public static void writeBytes(String fileName, byte[] bytes) throws IOException {
        Files.write(Paths.get(fileName), bytes);
    }

    public static void copy(String resourceFileName, String destinationFileName) throws IOException {
        Files.copy(Paths.get(resourceFileName), Paths.get(destinationFileName));
    }
}
```

# Task 2
```java
public class Solution extends SimpleFileVisitor<Path> {
    public static void main(String[] args) throws IOException {
        EnumSet<FileVisitOption> options = EnumSet.of(FileVisitOption.FOLLOW_LINKS);
        final Solution solution = new Solution();
        Files.walkFileTree(Paths.get("D:/"), options, 20, solution);

        List<String> result = solution.getArchived();
        System.out.println("All archived files:");
        for (String path : result) {
            System.out.println("\t" + path);
        }

        List<String> failed = solution.getFailed();
        System.out.println("All failed files:");
        for (String path : failed) {
            System.out.println("\t" + path);
        }
    }

    private List<String> archived = new ArrayList<>();
    private List<String> failed = new ArrayList<>();

    public List<String> getArchived() {
        return archived;
    }

    public List<String> getFailed() {
        return failed;
    }

    public FileVisitResult visitFile(Path path, BasicFileAttributes basicFileAttributes) throws IOException {
        if (path.toString().endsWith(".zip") || path.toString().endsWith(".rar")) {
            archived.add(path.toString());
        }
        return super.visitFile(path, basicFileAttributes);


    }

    public FileVisitResult visitFileFailed(Path path, IOException e) throws IOException {
        failed.add(path.toString());
        return FileVisitResult.SKIP_SUBTREE;

    }
}
```

# Task 3
```java
public class Solution {

    public static void main(String[] args) throws IOException {
        Path passwords = downloadFile("https://javarush.ru/testdata/secretPasswords.txt", Paths.get("D:/MyDownloads"));

        for (String line : Files.readAllLines(passwords)) {
            System.out.println(line);
        }
    }

    public static Path downloadFile(String urlString, Path downloadDirectory) throws IOException {
        // implement this method
        String name = urlString.split("/")[urlString.split("/").length - 1];
        Path file = downloadDirectory.resolve(name);

        URL url = new URL(urlString);
        InputStream inputStream = url.openStream();
        
        Path temp = Files.createTempFile(urlString, ".txt");
        Files.copy(inputStream, temp);

        Files.move(temp, file);

        return file;

    }
}
```

# Task 4
```java
public class Solution {

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String pathStr = reader.readLine();

        Path path = Paths.get(pathStr);

        if (!Files.isDirectory(path)) {
            System.out.println(path.toString() + " - не папка");
        } else {
            AtomicInteger dir = new AtomicInteger();
            AtomicInteger files = new AtomicInteger();
            AtomicLong size = new AtomicLong();

            Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
                public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attributes) {
                    if (!file.equals(path)) {
                        dir.incrementAndGet();
                    }
                    return FileVisitResult.CONTINUE;
                }


                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {
                    files.incrementAndGet();
                    size.addAndGet(attributes.size());
                    return FileVisitResult.CONTINUE;
                }

            });

            System.out.println("Загалом папок - " + dir.get());
            System.out.println("Загалом файлів - " + files.get());
            System.out.println("Загальний розмір - " + size.get());
        }



    }
}
```

<br><br>
32 lvl - 6 lecture. JavaRush

# Task 1
```java
public class Solution {
    public static void main(String[] args) throws IOException {
        File resultFileName = new File(args[0]);
        if (!resultFileName.exists()) {
            resultFileName.createNewFile();
        }

        List<String> list = new ArrayList<>();
        list.addAll(Arrays.asList(args).subList(1, args.length));
        Collections.sort(list);

        List<FileInputStream> fileInputStreamList = new ArrayList<>();
        for (String s : list) {
            fileInputStreamList.add(new FileInputStream(s));
        }

        try (ZipInputStream zipInputStream = new ZipInputStream(new SequenceInputStream(Collections.enumeration(fileInputStreamList)))) {
            while (true) {
                ZipEntry zipEntry = zipInputStream.getNextEntry();
                if (zipEntry == null) {
                    break;
                }

                try (OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(resultFileName))) {
                    int bufferInt = 1024;
                    byte[] buffer = new byte[bufferInt];

                    int readBytes;

                    while ((readBytes = zipInputStream.read(buffer, 0, bufferInt)) > -1) {
                        outputStream.write(buffer, 0, readBytes);
                    }
                }
            }
        }
    }
}
```

# Task 2
```java
// The very hard one
public class Solution {
    public static void main(String[] args) throws IOException {

        File file = new File(args[0]);

        FileOutputStream fileOutPutStream = new FileOutputStream(args[1]);
        ZipOutputStream zipOutput = new ZipOutputStream(fileOutPutStream);

        zipOutput.putNextEntry(new ZipEntry("new/" + file.getName()));

        Files.copy(file.toPath(), zipOutput);

        List<Content> list = getContents(args[1]);

        for (Content content : list) {
            if (!content.getFileName().equals("new/" + file.getName())) content.saveToZip(zipOutput);
        }

        // закриваємо архів
        zipOutput.close();
    }

    private static List<Content> getContents(String arg) throws IOException {
        List<Content> entries = new ArrayList<>();
        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(arg))) {
            ZipEntry currentEntry;
            byte[] buffer = new byte[1024];
            while ((currentEntry = zipInputStream.getNextEntry()) != null) {
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                int length = 0;
                while ((length = zipInputStream.read(buffer)) > 0) {
                    outputStream.write(buffer, 0, length);
                }
                entries.add(new Content(currentEntry.getName(), outputStream.toByteArray()));
            }
        }
        return entries;
    }

    static class Content {
        String fileName;
        byte[] body;

        Content(String fileName, byte[] body) {
            this.fileName = fileName;
            this.body = body;
        }

        public String getFileName() {
            return fileName;
        }

        void saveToZip(ZipOutputStream zip) throws IOException {
            ZipEntry zipEntry = new ZipEntry(fileName);
            zip.putNextEntry(zipEntry);
            zip.write(body);
            zip.closeEntry();
        }
    }
}
```
